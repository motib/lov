<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="lov.css">
<TITLE>2&#XA0;&#XA0;Learning Objects for Methods</TITLE>
</HEAD>
<BODY >
<A HREF="lov004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="lov006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H2 CLASS="section"><A NAME="htoc11">2</A>&#XA0;&#XA0;Learning Objects for Methods</H2><P><A NAME="s.method"></A></P><P><B>Concept</B> <EM>Methods</EM> are the simplest construct for abstraction
in Java. A method starts with a declaration that defines its <EM>signature</EM>:
the name of the method, the number and types of the <EM>formal parameters</EM> 
and the <EM>return type</EM>.
The body of the method consists of local variable declarations and of statements.
A method is <EM>called</EM> or <EM>invoked</EM> by writing the name of the method
followed by a list of values, called <EM>actual parameters</EM>, one for
each formal parameter. A method can return a value or it can be declared
as <TT>void</TT> if no value is returned.</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>LO</TD><TD ALIGN=left NOWRAP>Topic</TD><TD ALIGN=left NOWRAP>Java Files (.java)</TD><TD ALIGN=center NOWRAP>Prerequisites</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.01">2.1</A></TD><TD ALIGN=left NOWRAP>A void method</TD><TD ALIGN=left NOWRAP>Method01</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.02">2.2</A></TD><TD ALIGN=left NOWRAP>A method returning a value</TD><TD ALIGN=left NOWRAP>Method02</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.03">2.3</A></TD><TD ALIGN=left NOWRAP>Calling one method from another</TD><TD ALIGN=left NOWRAP>Method03</TD><TD ALIGN=center NOWRAP>1, 2</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.04">2.4</A></TD><TD ALIGN=left NOWRAP>Recursion</TD><TD ALIGN=left NOWRAP>Method04</TD><TD ALIGN=center NOWRAP>2</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.05">2.5</A></TD><TD ALIGN=left NOWRAP>Calling methods on an object</TD><TD ALIGN=left NOWRAP>Method05</TD><TD ALIGN=center NOWRAP>2, *</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.06">2.6</A></TD><TD ALIGN=left NOWRAP>Calling a method on the same object</TD><TD ALIGN=left NOWRAP>Method06</TD><TD ALIGN=center NOWRAP>5, *</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.07">2.7</A></TD><TD ALIGN=left NOWRAP>Objects as parameters</TD><TD ALIGN=left NOWRAP>Method07</TD><TD ALIGN=center NOWRAP>5, *</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.08">2.8</A></TD><TD ALIGN=left NOWRAP>Returning objects</TD><TD ALIGN=left NOWRAP>Method08</TD><TD ALIGN=center NOWRAP>7, *</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#method.09">2.9</A></TD><TD ALIGN=left NOWRAP>Returning locally instantiated objects</TD><TD ALIGN=left NOWRAP>Method09</TD><TD ALIGN=center NOWRAP>8, *</TD></TR>
</TABLE>
</DIV><P>
* This LO assumes knowledge of the declaration of
classes and the instantiation of objects.</P><H3 CLASS="subsection"><A NAME="htoc12">2.1</A>&#XA0;&#XA0;A void method</H3><P><A NAME="method.01"></A></P><P><B>Concept</B> When a method that is declared <TT>void</TT> is called,
it allocates memory for its parameters and local variables, executes
its statements and then returns. The call is a statement constructed
from the name of the method followed by a list of actual parameters.</P><P><B>Program: Method01.java</B>
, <A HREF="src/method/Method01.java">click to display source</A>.<BR>

The program computes the maximum of two integer values.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variables <TT>x</TT> and <TT>y</TT> are allocated and initialized.
</LI><LI CLASS="li-itemize">The method is called with the values of the actual parameters <TT>x</TT> and <TT>y</TT>.
</LI><LI CLASS="li-itemize">Memory is allocated for the formal parameters of the method and the local variables.
This is called an <EM>activation record</EM> and is displayed by <SPAN STYLE="font-variant:small-caps">Jeliot</SPAN> in the upper left
hand part of the screen labeled <TT>Method Area</TT>. The new activation record hides
the previous ones which are no longer accessible.
</LI><LI CLASS="li-itemize">The actual parameters are used to initialize the formal parameters in the activation
record.
</LI><LI CLASS="li-itemize">The local variable <TT>max</TT> is allocated within the activation record.
</LI><LI CLASS="li-itemize">The statements of the method are executed.
</LI><LI CLASS="li-itemize">After the last statement has been executed, the method <EM>returns</EM>
and the activation record is deallocated.
</LI><LI CLASS="li-itemize">Execution continues with the statement after the method call.
Here, the method is called again, this time with an integer literal
as an actual parameter instead of a variable. 
</LI></UL><P>
<B>Note:</B> In a call to a static method, the name of the 
class in which it is defined can be given as in the second call.
Since the method is defined in the <EM>same</EM> class as the call,
the class name need not be given, as shown in the first call.</P><P><B>Exercise</B> Trace the execution of a call of the following method and
explain why it doesn&#X2019;t swap the values of the actual parameters.
</P><BLOCKQUOTE CLASS="quote">
<TT>void swap(int a, int b) {</TT><BR>
&#XA0;&#XA0;<TT>int temp = a; a = b; b = temp;</TT><BR>
<TT>}</TT>
</BLOCKQUOTE><P>
Can you write a method to swap two integer values?
</P><H3 CLASS="subsection"><A NAME="htoc13">2.2</A>&#XA0;&#XA0;A method returning a value</H3><P><A NAME="method.02"></A></P><P><B>Concept</B> When a method that is declared with a return type is called,
it allocates memory for its parameters and local variables, executes
its statements and then returns a value of the type. 
The call is a statement constructed
from the name of the method followed by a list of actual parameters;
the call is an expression and can appear wherever an expression is allowed.</P><P><B>Program: Method02.java</B>
, <A HREF="src/method/Method02.java">click to display source</A>.<BR>

</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variables <TT>x</TT> and <TT>y</TT> are allocated and initialized;
the variable <TT>max</TT> is allocated but not initialized.
</LI><LI CLASS="li-itemize">An assignment statement is executed: the expression on the right hand side is
a method call including the values of the actual parameters <TT>x</TT> and <TT>y</TT>.
</LI><LI CLASS="li-itemize">Memory is allocated for the formal parameters of the method and the local variables.
This is called an <EM>activation record</EM> and is displayed by <SPAN STYLE="font-variant:small-caps">Jeliot</SPAN> in the upper left
hand part of the screen labeled <TT>Method Area</TT>. The new activation record hides
the previous ones which are no longer accessible.
</LI><LI CLASS="li-itemize">The actual parameters are used to initialize the formal parameters in the activation
record.
</LI><LI CLASS="li-itemize">The statements of the method are executed.
</LI><LI CLASS="li-itemize">When the statement <TT>return b</TT> is executed, the value of <TT>b</TT> is used
for the value to be returned.
</LI><LI CLASS="li-itemize">The method <EM>returns</EM> and the activation record is deallocated.
</LI><LI CLASS="li-itemize">The value returned becomes the value of the expression assigned to the
variable <TT>max</TT>.
</LI><LI CLASS="li-itemize">The value of <TT>max</TT> is printed.
</LI></UL><P><B>Exercise</B> Write the body of the main method as one statement.

</P><H3 CLASS="subsection"><A NAME="htoc14">2.3</A>&#XA0;&#XA0;Calling one method from another</H3><P><A NAME="method.03"></A></P><P><B>Concept</B> One method can call another, that is, when executing
one method, any statement or expression call be a method call. A sequence
of method calls results in a <EM>stack</EM> of activation records,
where each method (except the last one that was called) 
is waiting for the method it called to return. 
There is no limit on the <EM>depth</EM> of method calls,
except of course the amount of memory allocated to the program.</P><P><B>Note:</B> The <TT>main</TT> method is a method like any other. 
The operating system can be considered as a program which calls the main method.
This call has a single parameter: an array of strings containing the contents
of the command line.</P><P><B>Program: Method03.java</B>
, <A HREF="src/method/Method03.java">click to display source</A>.<BR>

</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <TT>main</TT> method calls the method <TT>printMax</TT>;
the actual parameters are two integer literals.
</LI><LI CLASS="li-itemize">The activation record for <TT>printMax</TT> is allocated,
and the actual parameters are used to initialize the formal parameters 
<TT>a</TT> and <TT>b</TT>.
</LI><LI CLASS="li-itemize">The variable <TT>max</TT> is allocated but not initialized.
</LI><LI CLASS="li-itemize">The method <TT>maximum</TT> is called; the actual parameters are the
values of <TT>a</TT> and <TT>b</TT>, 
which are the formal variables of method <TT>printMax</TT>.
</LI><LI CLASS="li-itemize">An activation record is allocated for <TT>maximum</TT>. (There are now
three activation in the stack.) The new activation record includes
memory for the formal parameters <TT>a</TT> and <TT>b</TT>; note that these are
new parameters not at all related to the formal parameters of the same names
in the previous method <TT>printMax</TT> because those parameters are hidden.
</LI><LI CLASS="li-itemize">The method <TT>maximum</TT> executes its body and returns a value.
Just before it returns, select the tab <TT>Call Tree</TT> above the graphic display;
the sequence of calls from <TT>main</TT> 
to <TT>printMax</TT> and then <TT>maximum</TT> is displayed.
Select <TT>Theater</TT> to return to the animated display.
</LI><LI CLASS="li-itemize">When the method returns, its activation record is deallocated, uncovering the
activation record of <TT>printMax</TT>. 
</LI><LI CLASS="li-itemize">The value returned is assigned to the variable <TT>max</TT> and printed.
</LI><LI CLASS="li-itemize">When <TT>printMax</TT> completes its execution, its activation record
is deallocated.
</LI></UL><P>
<B>Note:</B> In a call to a static method, the name of the 
class in which it is defined can be given as in the call to <TT>maximum</TT>.
Since the method is defined in the same class as the call,
the class name need not be given, as shown in the call to <TT>printMax</TT>.</P><P><B>Exercise</B> Write a program to compute the maximum of six values
using as few statements as possible.

</P><H3 CLASS="subsection"><A NAME="htoc15">2.4</A>&#XA0;&#XA0;Recursion</H3><P><A NAME="method.04"></A></P><P><B>Concept</B> <EM>Recursion</EM> occurs when method calls itself.
There is nothing at all mysterious about recursion!
Each call simply creates a new activation record on the stack.
However, to ensure that the recursive calls terminate,
eventually, some call of the method should return without
invoking itself once again.</P><P><B>Program: Method04.java</B>
, <A HREF="src/method/Method04.java">click to display source</A>.<BR>

The standard example of a recursive method is one
that computes the factorial function:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I>!&#XA0;=&#XA0;<I>n</I>&#XB7;&#XA0;(<I>n</I>&#X2212;1)&#XA0;&#XB7;&#XA0;&#X22EF;&#XA0;&#XB7;&#XA0;2&#XA0;&#XB7;&#XA0;1&#XA0;=&#XA0;<I>n</I>&#XA0;&#XB7;&#XA0;(<I>n</I>&#X2212;1)!
</TD></TR>
</TABLE><P>
The recursion is terminated by defining <I>n</I>!=1 for <I>n</I>&#X2264; 1.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <TT>main</TT> method calls the method <TT>factorial</TT>
with the actual parameter 5. This creates an activation record with
the formal parameter <TT>n</TT> initialized to 5.
</LI><LI CLASS="li-itemize">To compute the expression in the second return statement,
the method <TT>factorial</TT> is called again, this time with the actual
parameter equal to 5&#X2212;1=4.
</LI><LI CLASS="li-itemize">The sequence of recursive calls continues five times,
each one allocating a new activation record with a new variable <TT>n</TT>.
</LI><LI CLASS="li-itemize">Finally, <TT>factorial</TT> is called with actual parameter 1.
This call creates a new activation record as usual, but does not
cause <TT>factorial</TT> to be invoked again. Instead,
the value 1 is returned and the activation record is deallocated.
Just before the method returns, select the tab <TT>Call Tree</TT> above the graphic display;
the sequence of calls from <TT>main</TT> to the sequence of recursive calls is displayed.
Select <TT>Theater</TT> to return to the animated display.
</LI><LI CLASS="li-itemize">The recursive sequence <EM>unfolds</EM>: each returned value
is used to compute a new value to be returned by that call of <TT>factorial</TT>.
</LI><LI CLASS="li-itemize">Finally, the value 120 is returned to the <TT>main</TT> method and printed.
</LI></UL><P><B>Exercise</B> Write a recursive method to compute the n&#X2019;th Fibonacci number: 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>fib</I>(0)&#XA0;=&#XA0;0,&#XA0;<I>fib</I>(1)&#XA0;=&#XA0;1,&#XA0;<I>fib</I>(<I>n</I>)&#XA0;=&#XA0;<I>fib</I>(<I>n</I>&#X2212;1)&#XA0;+&#XA0;<I>fib</I>(<I>n</I>&#X2212;2)&#XA0;&#XA0;&#XA0;<I><I>for</I></I>&#XA0;&#XA0;&#XA0;<I>n</I>&#XA0;&gt;&#XA0;1.	
</TD></TR>
</TABLE><P><B>Exercise</B> Write a more efficient nonrecursive method for the same function.

</P><H3 CLASS="subsection"><A NAME="htoc16">2.5</A>&#XA0;&#XA0;Calling methods on an object</H3><P><A NAME="method.05"></A></P><P><B>Concept</B> Nonstatic methods defined in a class must be invoked
<EM>on</EM> an object of the class. A reference to the object becomes
an <EM>implicit</EM> actual parameter that initializes a formal variable called
<TT>this</TT> in the method. The variable <TT>this</TT> need not be 
explicitly mentioned when accessing fields of the object unless there is an ambiguity.</P><P><B>Program: Method05.java</B>
, <A HREF="src/method/Method05.java">click to display source</A>.<BR>

This program computes the cost of a song as the product of its length
in seconds and the price per second. A class <TT>Song</TT> is defined
to encapsulate the field <TT>seconds</TT> and the method <TT>computePrice</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Two objects of class Song are instantiated and references to them
are assigned to the variables <TT>song1</TT> and <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The method <TT>computePrice</TT> is called <EM>on</EM> the object referenced by <TT>song1</TT>. In <SPAN STYLE="font-variant:small-caps">Jeliot</SPAN> this is visualized by an arrow to the object
placed in the <TT>Expression Evaluation Area</TT> followed by a period and
the method name and parameters.
</LI><LI CLASS="li-itemize">An activation record is allocated containing two formal parameters:
<TT>this</TT> is initialized by the implicit reference and <TT>pricePerSecond</TT>
is initialized from the actual parameter.
</LI><LI CLASS="li-itemize">The reference in the parameter <TT>this</TT> is used to obtain 
the value of the field <TT>seconds</TT>. An expression is evaluated and
its value returned.
</LI><LI CLASS="li-itemize">The activation record is deallocated and the value returned is stored in the variable <TT>price1</TT>.
</LI><LI CLASS="li-itemize">A second call to the method is executed in exactly the same way,
except that it is called <EM>on</EM> the object referenced by <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The values of <TT>price1</TT> and <TT>price2</TT> are printed.
</LI></UL><P><B>Exercise</B> Modify the method so that the formal parameter is <EM>also</EM> 
named <TT>seconds</TT>. Yes, it can be done! 
(Hint: read the <B>Concept</B> paragraph above.)

</P><H3 CLASS="subsection"><A NAME="htoc17">2.6</A>&#XA0;&#XA0;Calling a method on the same object</H3><P><A NAME="method.06"></A></P><P><B>Concept</B> A nonstatic method defined in a class that is invoked
<EM>on</EM> an object of the class can invoke another such method on the same object.
The object for the second call is the same as the one on the first call,
namely, the only referenced by <TT>this</TT>.
There is no need to explicitly write <TT>this</TT> and the object may be accessed implicitly.</P><P><B>Program: Method06A.java</B>
, <A HREF="src/method/Method06A.java">click to display source</A>.<BR>

This program computes the cost of a song as the product of its length
in seconds and the price per second. A discount is applied
to &#X201C;long&#X201D; songs. A class <TT>Song</TT> is defined
to encapsulate the field <TT>seconds</TT> and the methods <TT>computePrice</TT>
and <TT>discount</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Two objects of class Song are instantiated and references to them
are assigned to the variables <TT>song1</TT> and <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The method <TT>computePrice</TT> is called <EM>on</EM> the object referenced by <TT>song1</TT>. In <SPAN STYLE="font-variant:small-caps">Jeliot</SPAN> this is visualized by an arrow to the object
placed in the <TT>Expression Evaluation Area</TT> followed by a period and
the method name and parameters.
</LI><LI CLASS="li-itemize">An activation record is allocated containing two formal parameters:
<TT>this</TT> is initialized by the implicit reference and <TT>pricePerSecond</TT>
is initialized from the actual parameter.
</LI><LI CLASS="li-itemize">The local variable <TT>price</TT> is declared and initialized by the
expression calculated from the formal parameter <TT>pricePerSecond</TT> and
the field of the object <TT>seconds</TT> that is implicitly accessed through <TT>this</TT>.
</LI><LI CLASS="li-itemize">The method <TT>discount</TT>, 
declared in the same class, is invoked and returns a boolean value.
A new activation is allocated for this method and deallocated when it terminates.
The implicit actual parameter is <TT>this</TT> and it is used to initialize the 
implicit formal parameter <TT>this</TT> of the method <TT>discount</TT>.
</LI><LI CLASS="li-itemize">The activation record for <TT>computePrice</TT> is deallocated 
and the value returned is stored in the variable <TT>price1</TT>.
</LI><LI CLASS="li-itemize">A second call to the method is executed exactly the same way,
except that it is called <EM>on</EM> the object referenced by <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The values of <TT>price1</TT> and <TT>price2</TT> are printed.
</LI></UL><P><B>Exercise</B> Modify the program so that discount does not use the explicit
parameter <TT>s</TT>.</P><P><BR>
<BR>
</P><P><B>Program: Method06B.java</B>
, <A HREF="src/method/Method06B.java">click to display source</A>.<BR>

Given a call to a method <TT>m2</TT> within a method <TT>m1</TT>:
</P><BLOCKQUOTE CLASS="quote">
<TT>void m1() {</TT><BR>
&#XA0;&#XA0;<TT>m2();</TT><BR>
<TT>}</TT>
</BLOCKQUOTE><P>
it is impossible to tell from the call if m2 is being implicitly called <EM>on</EM>
the same object or if it is a static method defined in the class.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
	This program is a modification of the previous one: instead of comparing
	<TT>s</TT> with 300 in the method <TT>discount</TT>, it is compared with
	the value returned by the method <TT>level</TT>. It is impossible to tell
	from the calls alone to <TT>discount</TT> and <TT>level</TT> that the first is
	a call on an object while the second is a call to a static method.
</LI></UL><P><B>Exercise</B> Modify the calls to <TT>discount</TT> and <TT>level</TT>
so that it is immediately apparent which is definitely a call on an object and which
is definitely a call to a static method.

</P><H3 CLASS="subsection"><A NAME="htoc18">2.7</A>&#XA0;&#XA0;Objects as parameters</H3><P><A NAME="method.07"></A></P><P><B>Concept</B> A reference to an object can be an actual parameter whose
corresponding formal parameter is declared to be of the same class.
As with all parameters, the <EM>value</EM> of actual parameter is used
to initialize the formal parameter, but since it is a reference that is
passed, the method that is called can access fields and methods of the
object. This is called <EM>reference semantics</EM>.</P><P><B>Program: Method07.java</B>
, <A HREF="src/method/Method07.java">click to display source</A>.<BR>

This program computes the cost of a song as the product of its length
in seconds and the price per second. A class <TT>Song</TT> is defined
to encapsulate the field <TT>seconds</TT> and the method <TT>computePrice</TT>.
The method <TT>getPrice</TT> in the <TT>main</TT> method receives an object of class
<TT>Song</TT> as a parameter and calls <TT>computePrice</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Two objects of class Song are instantiated and references to them
are assigned to the variables <TT>song1</TT> and <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The method <TT>getPrice</TT> is called with two parameters:
the first is a reference <TT>song1</TT> to an object of class <TT>Song</TT>, while the second
is a value of type double. The actual parameters are used to initialize the formal
parameters; check that <TT>song1</TT> and <TT>s</TT> reference the same object.
</LI><LI CLASS="li-itemize">Since the formal parameter <TT>s</TT> receives a reference to an object
of class <TT>Song</TT> (in this case <TT>song1</TT>), it can be used to call
the method <TT>computePrice</TT> declared in the class.
</LI><LI CLASS="li-itemize">The method returns a value that is assigned to <TT>price1</TT>.
</LI><LI CLASS="li-itemize">A second call to the method is executed exactly the same way,
except that the actual parameter is the reference contained in <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The values of <TT>price1</TT> and <TT>price2</TT> are printed.
</LI></UL><P><B>Exercise</B> Modify the program so that discount does not use the explicit
parameter <TT>s</TT>.

</P><H3 CLASS="subsection"><A NAME="htoc19">2.8</A>&#XA0;&#XA0;Returning objects</H3><P><A NAME="method.08"></A></P><P><B>Concept</B> A return value can be a reference to an object.</P><P><B>Program: Method08.java</B>
, <A HREF="src/method/Method08.java">click to display source</A>.<BR>

This program computes the cost of a song as the product of its length
in seconds and the price per second. A class <TT>Song</TT> is defined
to encapsulate the field <TT>seconds</TT> and the method <TT>computePrice</TT>.
The method <TT>longer</TT> in the <TT>main</TT> method receives references
to two objects of class <TT>Song</TT> as parameters and returns a reference
to the one with the larger value of the field <TT>seconds</TT>.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Two objects of class Song are instantiated and references to them
are assigned to the variables <TT>song1</TT> and <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The method <TT>longer</TT> is called with two parameters
that are references to objects of class <TT>Song</TT>.
The actual parameters are used to initialize the formal
parameters; check that <TT>song1</TT> and <TT>s1</TT> reference the same object,
as do <TT>song2</TT> and <TT>s2</TT>.
</LI><LI CLASS="li-itemize">Since the formal parameters <TT>s1</TT> and <TT>s2</TT> receive references to objects
of class <TT>Song</TT>, they can be used to access the fields <TT>seconds</TT> of each object.
</LI><LI CLASS="li-itemize">The method returns the reference to the object whose field <TT>seconds</TT>
has the larger value. The reference is assigned to the variable <TT>longerSong</TT>;
check that this reference is to the same object as the reference in <TT>song1</TT>.
</LI><LI CLASS="li-itemize">The reference in <TT>longerSong</TT> is used to call the method <TT>computePrice</TT>
and the value returned is assigned to the variable <TT>price2</TT>.
</LI><LI CLASS="li-itemize">The value <TT>price2</TT> is printed.
</LI></UL><P><B>Exercise</B> Modify the program so that discount does not use the explicit
parameter <TT>s</TT>.</P><P><B>Exercise</B> Replace the last declaration and statements of the program by one
declaration.</P><P><B>Exercise</B> Write a method to swap two integer values.

</P><H3 CLASS="subsection"><A NAME="htoc20">2.9</A>&#XA0;&#XA0;Returning locally instantiated objects</H3><P><A NAME="method.09"></A></P><P><B>Concept</B> When a method terminates, its activation record is deallocated.
However, if an object has been instantiated <EM>within the method</EM>,
a reference to the object can be returned to the calling method.</P><P><B>Program: Method09.java</B>
, <A HREF="src/method/Method09.java">click to display source</A>.<BR>

This program computes the cost of a song as the product of its length
in seconds and the price per second. A class <TT>Song</TT> is defined
to encapsulate the field <TT>seconds</TT> and the method <TT>computePrice</TT>.
The method <TT>double</TT> in the <TT>main</TT> method receives a reference
to an object of class <TT>Song</TT> as a parameter and returns a reference
to an new object of class <TT>Song</TT> whose field <TT>seconds</TT> is twice as large.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Two objects of class Song are instantiated and references to them
are assigned to the variables <TT>song1</TT> and <TT>song2</TT>.
</LI><LI CLASS="li-itemize">The method <TT>doubleSong</TT> is called with an actual parameter
that is a reference <TT>song1</TT> to an object of class <TT>Song</TT>.
The actual parameter is used to initialize the formal
parameter; check that <TT>song1</TT> and <TT>s1</TT> reference the same object.
</LI><LI CLASS="li-itemize"><EM>Within the method</EM>, the <TT>seconds</TT> field of the object referenced
by <TT>s1</TT> is used to instantiate a new object whose reference is assigned
to the variable <TT>d</TT> of class <TT>Song</TT>.
</LI><LI CLASS="li-itemize">The method returns the reference to the object contained in <TT>d</TT>;
although <TT>d</TT> disappears when the activation record is deallocated,
the object still exists as does the reference that is returned.
</LI><LI CLASS="li-itemize">The returned reference is assigned to the variable <TT>longSong</TT>;
check that <TT>song1</TT> and <TT>longSong</TT> reference <EM>different</EM> objects!
</LI></UL><P><B>Exercise</B> Replace the last line of the program by:
</P><BLOCKQUOTE CLASS="quote">
<TT>song1 = doubleSong(song1);</TT>
</BLOCKQUOTE><P>
and explain precisely what happens.</P><HR>
<A HREF="lov004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="lov006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
