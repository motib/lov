<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="lov.css">
<TITLE>5&#XA0;&#XA0;Learning Objects for Inheritance</TITLE>
</HEAD>
<BODY >
<A HREF="lov007.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<HR>
<H2 CLASS="section"><A NAME="htoc40">5</A>&#XA0;&#XA0;Learning Objects for Inheritance</H2><P><A NAME="s.inheritance"></A></P><P><B>Concept</B> <EM>Inheritance</EM> is an important technique for 
structuring object-oriented programs. Given a class (called a 
<EM>superclass</EM>) it can be extended to a <EM>subclass</EM>. The 
subclass inherits all the fields of the superclass and it can add 
additional fields. The subclass inherits methods of the superclass and it can 
add new methods or override the inherited methods with its own versions.</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>LO</TD><TD ALIGN=left NOWRAP>Topic</TD><TD ALIGN=left NOWRAP>Java Files (.java)</TD><TD ALIGN=center NOWRAP>Prerequisites</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.01">5.1</A></TD><TD ALIGN=left NOWRAP>Inheriting fields</TD><TD ALIGN=left NOWRAP>Inheritance01</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.02">5.2</A></TD><TD ALIGN=left NOWRAP>Inheriting and overriding methods</TD><TD ALIGN=left NOWRAP>Inheritance02</TD><TD ALIGN=center NOWRAP>1</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.03">5.3</A></TD><TD ALIGN=left NOWRAP>Dynamic dispatching</TD><TD ALIGN=left NOWRAP>Inheritance03</TD><TD ALIGN=center NOWRAP>2</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.04">5.4</A></TD><TD ALIGN=left NOWRAP>Downcasting</TD><TD ALIGN=left NOWRAP>Inheritance04</TD><TD ALIGN=center NOWRAP>3</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.05">5.5</A></TD><TD ALIGN=left NOWRAP>Heterogeneous data structures</TD><TD ALIGN=left NOWRAP>Inheritance05</TD><TD ALIGN=center NOWRAP>4</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.06">5.6</A></TD><TD ALIGN=left NOWRAP>Abstract classes</TD><TD ALIGN=left NOWRAP>Inheritance06</TD><TD ALIGN=center NOWRAP>5</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.07">5.7</A></TD><TD ALIGN=left NOWRAP>Equals</TD><TD ALIGN=left NOWRAP>Inheritance07A, B, C</TD><TD ALIGN=center NOWRAP>2</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.08">5.8</A></TD><TD ALIGN=left NOWRAP>Clone</TD><TD ALIGN=left NOWRAP>Inheritance08</TD><TD ALIGN=center NOWRAP>2</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#inher.09">5.9</A></TD><TD ALIGN=left NOWRAP>Overloading vs. overriding</TD><TD ALIGN=left NOWRAP>Inheritance09</TD><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE>
</DIV><P><B>Program</B> The running example is a framework for the simulation of 
moving particles. There is a class <TT>Particle</TT> with a field 
<TT>position</TT> that is updated by the method <TT>newPosition</TT>. 
There are three subclasses:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
	<TT>AParticle</TT> is derived directly from <TT>Particle</TT> and adds the field
	<TT>spin</TT>.<BR>
The method <TT>newPosition</TT> is overridden.
	</LI><LI CLASS="li-itemize"><TT>BParticle</TT> is derived directly from <TT>Particle</TT> and adds the field
	<TT>charge</TT>.<BR>
The method <TT>newPosition</TT> is <EM>not</EM> overridden.
	</LI><LI CLASS="li-itemize"><TT>CParticle</TT> is derived directly from <TT>BParticle</TT> and thus
	indirectly from <TT>AParticle</TT>.<BR>
It adds the field
	<TT>strange</TT>; the method <TT>newPosition</TT> is overridden.
</LI></UL><P>For each program the following initialization is performed and will not
be explicitly mentioned for each learning object; instead, the step 
&#X201C;the objects are created&#X201D; will be listed:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Variable are declared and assigned the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for each object&#X2019;s fields and are given default
values. For a subclass, these fields include all fields of its superclasses.
</LI><LI CLASS="li-itemize">In the constructors, a subclass calls <TT>super</TT> to initialize
the fields declared by the superclasses and then initializes its own fields.
</LI></UL><P><B>Tip:</B> Use <TT>Animation / Run Until ...</TT> to skip over the animation
of the initialization.</P><P><B>Tip:</B> Several of the LOs will ask you to check that a certain version
of a method is called. This can be done by looking at the source code in the left panel:
the method called is highlighted in blue.</P><H3 CLASS="subsection"><A NAME="htoc41">5.1</A>&#XA0;&#XA0;Inheriting fields</H3><P><A NAME="inher.01"></A></P><P><B>Concept</B> 
Subclasses inherit all the fields of its superclasses; they can also add
fields of their own.</P><P><B>Program: Inheritance01.java</B>
, <A HREF="src/inheritance/Inheritance01.java">click to display source</A>.<BR>

In this simple program objects of all four classes are created and their fields
are read.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The objects are created.
</LI><LI CLASS="li-itemize">For each field of each object, a variable is declared in the main method
and the value of the field is assigned to it. Check that each value originates
from the correct field.
</LI></UL><P><B>Exercise</B> In <TT>CParticle</TT>, add the declaration <TT>int
charge = -1;</TT>. Compile and run the program. Is the output different?
Explain what happens.

</P><H3 CLASS="subsection"><A NAME="htoc42">5.2</A>&#XA0;&#XA0;Inheriting methods</H3><P><A NAME="inher.02"></A></P><P><B>Concept</B> 
Subclasses inherit the methods of its superclasses and can add new methods 
of its own. You can override an inherited method by writing a new method 
with <EM>the same signature</EM> as the inherited method.</P><P><B>Program: Inheritance02.java</B>
, <A HREF="src/inheritance/Inheritance02.java">click to display source</A>.<BR>

This program calls the method <TT>newPosition</TT>, which 
is overridden in <TT>AParticle</TT> and <TT>CParticle</TT> but not in 
<TT>BParticle</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The objects are created.
</LI><LI CLASS="li-itemize">Method <TT>newPosition</TT> is invoked for each object and the modified
value of <TT>position</TT> is assigned to a variable.
</LI><LI CLASS="li-itemize">Check that the call on <TT>p</TT> calls the method defined in class 
<TT>Particle</TT>.
</LI><LI CLASS="li-itemize">Check that the call on <TT>a</TT> calls the method defined 
in the class <TT>AParticle</TT>; this method overrides the method declared 
in class <TT>Particle</TT>.
</LI><LI CLASS="li-itemize">Check that the call on <TT>b</TT> calls the method defined 
in the superclass <TT>Particle</TT>; since the method was <EM>not</EM> overridden
in <TT>BParticle</TT>, the method called is the one inherited from the superclass.
</LI><LI CLASS="li-itemize">Check that the call on <TT>c</TT> calls the method defined 
in the class <TT>BParticle</TT>; this method overrides the method declared 
in class <TT>Particle</TT>.
</LI></UL><P><B>Exercise</B> Remove the method <TT>newPosition</TT> from
<TT>CParticle</TT>. Which method is invoked for <TT>c.newPosition</TT>?</P><P><B>Exercise</B> Remove the method <TT>newPosition</TT> from
<TT>CParticle</TT> and add a method with the same signature to
<TT>BParticle</TT>. Which method is invoked for <TT>c.newPosition</TT>?

</P><H3 CLASS="subsection"><A NAME="htoc43">5.3</A>&#XA0;&#XA0;Dynamic dispatching</H3><P><A NAME="inher.03"></A></P><P><B>Concept</B> A variable <TT>v</TT> of type <TT>T</TT> can contain a 
reference to an object of type <TT>T</TT> or of the type of any subclass of 
<TT>T</TT>. When invoking <TT>v.m</TT> for some method <TT>m</TT> that is 
overridden in a subclass, it is the type of the <EM>object</EM> currently 
referenced by <TT>v</TT> (not the type of the <EM>variable</EM> <TT>v</TT>) that determines which method is called. This is 
called <EM>dynamic dispatching</EM> because the call is dispatched at 
runtime.</P><P><B>Program: Inheritance03.java</B>
, <A HREF="src/inheritance/Inheritance03.java">click to display source</A>.<BR>

</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The objects are created.
</LI><LI CLASS="li-itemize">The references to the objects are assigned one-by-one to the variable <TT>p</TT>,
and then the method <TT>newPosition</TT> is invoked using <TT>p</TT>. The modified
value of <TT>position</TT> is assigned to a variable.
</LI><LI CLASS="li-itemize">Check that the call on <TT>p</TT> invokes the method defined in class 
<TT>Particle</TT>.
</LI><LI CLASS="li-itemize">After assigning <TT>a</TT> to <TT>p</TT>, check that the call invokes the
method defined in the class <TT>AParticle</TT>; this method overrides the method declared 
in class <TT>Particle</TT>. Although the type of <TT>p</TT> is class
<TT>Particle</TT>, it holds a reference to an object whose type is 
class <TT>AParticle</TT> so the method of that class is called.
</LI><LI CLASS="li-itemize">Note that as a result of the assignment, the object of type <TT>Particle</TT>
has become garbage.
</LI><LI CLASS="li-itemize">After assigning <TT>b</TT> to <TT>p</TT>, check that the call invokes the
method defined in the superclass <TT>Particle</TT>; since the method was <EM>not</EM>
overridden in <TT>BParticle</TT>, the method called is the one inherited from the
superclass.
</LI><LI CLASS="li-itemize">After assigning <TT>c</TT> to <TT>p</TT>, check that the call invokes the
method defined in the class <TT>CParticle</TT>; this method overrides the method declared 
in class <TT>Particle</TT>. Although the type of <TT>p</TT> is class
<TT>Particle</TT>, it holds a reference to an object whose type is
class <TT>CParticle</TT> so the method of that class is called.
</LI></UL><P><B>Exercise</B> Add an assignment of <TT>c</TT> to <TT>b</TT> and call
<TT>b.newPosition(10)</TT>. What is the value now of <TT>b.position</TT>?

</P><H3 CLASS="subsection"><A NAME="htoc44">5.4</A>&#XA0;&#XA0;Downcasting</H3><P><A NAME="inher.04"></A></P><P><B>Concept</B> A variable of the type of a class can reference an object 
of the type of a <EM>subclass</EM>, but this variable cannot be used to access fields 
declared in the subclass.
Nevertheless, the object &#X201C;remembers&#X201D; its type, even if it is assigned 
to a variable of the type of its superclass, and the type can be &#X201C;recovered&#X201D;
by casting to a variable of the type of the subclass. 
This is called 
<EM>downcasting</EM> because the cast is &#X201C;down&#X201D; the derivation hierarchy.</P><P><B>Program: Inheritance04.java</B>, <A HREF="src/inheritance/Inheritance04.java">click to display source</A>.<BR>

In this program, we take an object of the type of the 
subclass <TT>AParticle</TT> and assign its reference to the variable 
<TT>p</TT> of the type of the superclass <TT>Particle</TT>. The object&#X2019;s 
actual type is recovered by downcasting from <TT>p</TT> to <TT>a</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The objects are created.
</LI><LI CLASS="li-itemize">The value of <TT>p.position</TT> is stored in a variable.
</LI><LI CLASS="li-itemize">The reference in the variable <TT>a</TT> is assigned to <TT>p</TT>.
Note that the arrows from the representation of both variables point to
the same object of type <TT>AParticle</TT>, and that the other object
is garbage.
</LI><LI CLASS="li-itemize">When the value of <TT>p.position</TT> is accessed, it refers to the value that 
is in <TT>a.position</TT>.
</LI><LI CLASS="li-itemize">The reference in <TT>p</TT> can be cast to the type <TT>AParticle</TT>
and assigned to <TT>a</TT>. Although <TT>p</TT> is declared to hold references to objects of
type <TT>Particle</TT>, the object was really of the subclass <TT>AParticle</TT>.
</LI><LI CLASS="li-itemize">Both the fields <TT>position</TT> and <TT>spin</TT> can be accessed 
through <TT>a</TT>.
</LI></UL><P><B>Exercise</B> What happens if you try to access <TT>p.spin</TT> after
<TT>a</TT> has been assigned to <TT>p</TT>?</P><P><B>Exercise</B> Add the statement <TT>BParticle b = (BParticle) p</TT>
after the assignment of <TT>a</TT> to <TT>p</TT>. Does the program compile
successfully? Does it run successfully? Explain the results.

</P><H3 CLASS="subsection"><A NAME="htoc45">5.5</A>&#XA0;&#XA0;Heterogeneous data structures</H3><P><A NAME="inher.05"></A></P><P><B>Concept</B> 
A heterogeneous data structure is one that can hold elements of different types. 
A data structure whose elements are of the type of a class can hold
references to objects of any subclass of that class.</P><P><B>Program: Inheritance05.java</B>
, <A HREF="src/inheritance/Inheritance05.java">click to display source</A>.<BR>

An array whose elements are of class <TT>Particle</TT> 
can store references to objects of any of its subclasses.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The objects are created and references to them assigned to elements
of the elements of the array <TT>p</TT>.
</LI><LI CLASS="li-itemize">Method <TT>newPosition</TT> is invoked for the object referenced 
by each element of the array <TT>p</TT>. 
Check that the fields accessed are those of the object referenced by the
array element and that the calls are dynamically dispatched to the method
appropriate for the type of the object.
</LI></UL><P><B>Exercise</B> Every object in Java is a subclass of the class 
<TT>Object</TT>. Modify the program so that the variable <TT>p</TT> is of 
type array of <TT>Object</TT>.

</P><H3 CLASS="subsection"><A NAME="htoc46">5.6</A>&#XA0;&#XA0;Abstract classes</H3><P><A NAME="inher.06"></A></P><P><B>Concept</B> Very often the &#X201C;root&#X201D; of a set of derived types has no 
meaning itself, in the sense that objects of that type would never be 
declared. For example, in a realistic simulation program, the would be no 
real particles that are just &#X201C;particles,&#X201D; only particles with names like 
&#X3B1;-particles and &#X3B2;-particles.
An <EM>abstract</EM> class can be declared which serves only as a root from 
which to derive a hierarchy of subclasses. 
It is not legal to declare <EM>objects</EM> of an abstract class, 
although <EM>variables</EM> of its type may be declared and used to 
reference objects of any type within the hierarchy. A method may also be 
declared abstract; this indicates that it <EM>must</EM> be overridden in 
subclasses.</P><P><B>Program: Inheritance06.java</B>
, <A HREF="src/inheritance/Inheritance06.java">click to display source</A>.<BR>

The follow program declares <TT>Particle</TT> to
be <TT>abstract</TT> and no objects of that class can be declared. The
method <TT>newPosition</TT> is also declared abstrct because it doesn&#X2019;t
make sense to have a particle that you can&#X2019;t move.</P><P><B>Exercise</B> The program does not compile successfully. Why? (Note that
in <SPAN STYLE="font-variant:small-caps">Jeliot</SPAN>, the problem is only found at when animating the program.)
Modify the program so that it compiles and executes.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The objects are created and references to them assigned to 
elements of the array.
</LI><LI CLASS="li-itemize">Method <TT>newPosition</TT> is invoked for the object referenced 
by each element of the array <TT>p</TT>. 
Check that the fields accessed are those of the object referenced by the
array element and that the calls are dynamically dispatched to the method
appropriate for the type of the object.
</LI></UL><P><B>Exercise</B> It is possible to declare a nonabsract method in an 
abstract class. Give an example for this program, and explain why it is a 
reasonable thing to do.

</P><H3 CLASS="subsection"><A NAME="htoc47">5.7</A>&#XA0;&#XA0;Equals</H3><P><A NAME="inher.07"></A></P><P><B>Concept</B> There are two concepts of equality in Java: the <EM>operator</EM> 
<TT>==</TT> compares primitives types and references, while the <EM>method</EM>
<TT>equals</TT> compares objects. The default implementation of 
<TT>equals</TT> is like <TT>==</TT>, but it can be overridden in any class.</P><P><B>Program: Inheritance07A.java</B> 
, <A HREF="src/inheritance/Inheritance07A.java">click to display source</A>.<BR>

</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Object <TT>a1</TT> of type <TT>AParticle</TT> is created.
</LI><LI CLASS="li-itemize"><TT>a1</TT> is assigned to <TT>a2</TT> using <TT>==</TT>.
</LI><LI CLASS="li-itemize">Object <TT>a3</TT> of type <TT>AParticle</TT> is created with the 
same values for its fields as the object referenced by <TT>a1</TT>.
</LI><LI CLASS="li-itemize">Evaluating <TT>a1==a2</TT> returns <EM>true</EM> because they both reference the same object.
</LI><LI CLASS="li-itemize">Evaluating <TT>a1==a3</TT> returns <EM>false</EM> because they reference different objects.
</LI><LI CLASS="li-itemize">Strangely enough, evaluating <TT>a1.equals(a3)</TT> returns <EM>false</EM>.
Although their fields are equal, the default implementation of <TT>equals</TT> is
the same as <TT>==</TT>!
</LI></UL><P><B>Exercise</B> Add the follow method to <TT>AParticle</TT> and run the
program again. What happens now?
</P><PRE CLASS="verbatim">   public boolean equals(AParticle a) {
        return this.position == a.position &amp;&amp; this.spin == a.spin;
   }
</PRE><P><BR>
<BR>
</P><P><B>Program: Inheritance07B.java</B>
, <A HREF="src/inheritance/Inheritance07B.java">click to display source</A>.<BR>

Let us try to override the method <TT>equals</TT> in classes <TT>BParticle</TT>
and <TT>CParticle</TT>; the method returns true if the all fields of the
two objects are equal.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Four objects are created: two equal objects <TT>b1</TT> and <TT>b2</TT>
of type <TT>BParticle</TT> and two unequal objects <TT>c1</TT> and <TT>c2</TT>
of type <TT>CParticle</TT>.
</LI><LI CLASS="li-itemize">As expected, <TT>b1.equals(b2)</TT> returns <EM>true</EM> and <TT>c1.equals(c2)</TT> returns <EM>false</EM>.
</LI><LI CLASS="li-itemize"><TT>b1.equals(c1)</TT> returns <EM>true</EM>: since <TT>CParticle</TT>
is a subclass of <TT>BParticle</TT>, the variable <TT>c1</TT> is acceptable
as a parameter to the method <TT>equals</TT> declared in <TT>BParticle</TT>.
<TT>c1</TT> <EM>is</EM> equal to <TT>b1</TT>, because we are only comparing 
the first two fields inherited from <TT>BParticle</TT> and these are equal.
</LI></UL><P><B>Exercise</B> Explain what happens if you try to evaluate <TT>c1.equals(b1)</TT>.</P><P><BR>
<BR>
</P><P><B>Program: Inheritance07C.java</B>
, <A HREF="src/inheritance/Inheritance07C.java">click to display source</A>.<BR>

It would be unusual for two objects to be considered equal if they
are of different types, even if one type is a subclass of another.
In fact, 
</P><BLOCKQUOTE CLASS="quote">
<TT>public boolean equals(CParticle c)</TT>
</BLOCKQUOTE><P>
does not override the method <TT>equals</TT> in <TT>BParticle</TT>,
because an overriding method must have the <EM>same signature</EM> as the overridden
method.</P><P>The method <TT>equals</TT> is declared in the root class <TT>Object</TT> as:
</P><BLOCKQUOTE CLASS="quote">
<TT>public boolean equals(Object obj)</TT>
</BLOCKQUOTE><P>
and this is the method that must be overridden.
This program shows the correct technique:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
	Since the parameter can now be any object, a check is first made that
	the parameter is not <TT>null</TT>.
	</LI><LI CLASS="li-itemize">Similarly, a check is made that the parameter is of the same
	type as this object.
	</LI><LI CLASS="li-itemize">Now that we know that the parameter is actually of this type,
	it can be cast from <TT>Object</TT> to the type.
	</LI><LI CLASS="li-itemize">Only then is class-specific code performed&#X2014;usually a field-by-field comparison.
</LI></UL><P>Trace the execution of the program:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Four objects are created: one object <TT>b1</TT> of type <TT>BParticle</TT> 
and three objects <TT>c1</TT>, <TT>c2</TT> and <TT>c3</TT> of type <TT>CParticle</TT>.
</LI><LI CLASS="li-itemize">Clearly, comparing <TT>c1</TT> to <TT>null</TT> or <TT>b1</TT> returns <EM>false</EM>.
</LI><LI CLASS="li-itemize">Field-by-field comparisons are used if the parameter is of type <TT>CParticle</TT>: <TT>c1.equals(c2)</TT> returns <EM>false</EM> and <TT>c1.equals(c3)</TT> returns <EM>true</EM>.
</LI></UL><P><B>Exercise</B> Move the declaration of <TT>equals</TT> to class
<TT>BParticle</TT>, changing the code as needed. What now is the value of
<TT>c1.equals(b1)</TT>? Explain.

</P><H3 CLASS="subsection"><A NAME="htoc48">5.8</A>&#XA0;&#XA0;Clone</H3><P><A NAME="inher.08"></A></P><P><B>Concept</B> Assigning a variable containing a reference to another
of the same type merely copies the 
reference so that two fields refer to the same object. The method 
<TT>clone</TT> is used to copy the content of an object into a new one. 
<TT>clone</TT> is defined in class <TT>Object</TT> and can be
overridden in any class definition.</P><P><B>Program: Inheritance08.java</B>
, <A HREF="src/inheritance/Inheritance09.java">click to display source</A>.<BR>

<TT>clone</TT> is overridden in class <TT>Particle</TT>. 
The class must implement the interface <TT>Cloneable</TT>, the 
method of the superclass should be called, and we have to take into 
account that the method might raise an exception. The method returns
the object returned by superclass method after calling <TT>newPosition</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
An object of class <TT>Particle</TT> is allocated and its reference 
assigned to the field <TT>p1</TT>. 
</LI><LI CLASS="li-itemize">An assignment statement copies this reference to the field <TT>p2</TT>. 
Check that they have the same value.
</LI><LI CLASS="li-itemize">The method <TT>newPosition</TT> is called on <TT>p1</TT>, but the 
value of <TT>p2.position</TT> is also changed, showing that the two fields 
point to the same object.
</LI><LI CLASS="li-itemize">An object of class <TT>Particle</TT> is obtained by calling <TT>p1.clone()</TT> and its reference assigned to the field <TT>p3</TT>. Since <TT>clone</TT> returns a value of type
<TT>Object</TT>, it must be cast to type <TT>Particle</TT> before the assignment.
Check that the objects referenced by <TT>p1</TT> and <TT>p3</TT> have different values.
</LI><LI CLASS="li-itemize">Calling <TT>p3.newPosition</TT> changes only the field in the object
referenced by <TT>p3</TT> and not the separate object referenced by <TT>p1</TT>.
</LI></UL><P><B>Exercise</B> The method <TT>clone</TT> can perform arbitrary 
computation. Modify the program so that new objects are initialized with 
the absolute value of the field of the object that is being cloned.

</P><H3 CLASS="subsection"><A NAME="htoc49">5.9</A>&#XA0;&#XA0;Overloading vs. overriding</H3><P><A NAME="inher.09"></A></P><P><B>Concept</B> <EM>Overloading</EM> is the use of the same method name with a 
<EM>different</EM> parameter signature. <EM>Overriding</EM> is the use in a subclass 
of the same method name with the <EM>same</EM> parameter signature as a method 
of the superclass.</P><P><B>Program: Inheritance09.java</B>
, <A HREF="src/inheritance/Inheritance09.java">click to display source</A>.<BR>

The method <TT>newPosition(int delta)</TT> is declared in <TT>Particle</TT> and
<EM>overridden</EM> in <TT>AParticle</TT>. It is also <EM>overloaded</EM> by a method
with the same name takes a parameter of type <TT>double</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
After allocating three objects <TT>p</TT>, <TT>a1</TT> and <TT>a2</TT>, <TT>newPosition</TT> is called on each one. 
</LI><LI CLASS="li-itemize"><TT>p.newPosition</TT> calls the method declared in class 
<TT>Particle</TT>.
</LI><LI CLASS="li-itemize"><TT>a1.newPosition</TT> calls the method declared 
in class <TT>AParticle</TT> that overrides the method in 
<TT>Particle</TT>. 
</LI><LI CLASS="li-itemize"><TT>a2.newPosition</TT> calls the overloaded method 
because the actual parameter is of type <TT>double</TT>.
</LI></UL><P><B>Exercise</B> At the end of the program add an assignment <TT>p = 
a1</TT>. Add the method invocations <TT>p.newPosition(10)</TT> and 
<TT>p.newPosition(10.0)</TT> in the main method. Explain what happens.


</P><HR>
<A HREF="lov007.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
</BODY>
</HTML>
