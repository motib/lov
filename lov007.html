<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="lov.css">
<TITLE>4&#XA0;&#XA0;Learning Objects for Constructors</TITLE>
</HEAD>
<BODY >
<A HREF="lov006.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="lov008.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H2 CLASS="section"><A NAME="htoc31">4</A>&#XA0;&#XA0;Learning Objects for Constructors</H2><P><A NAME="s.constructors"></A></P><P><B>Concept</B> The process of creating an object involves allocating memory for the object and assigning the reference to this block of memory to a variable. <EM>Constructors</EM> enable arbitrary initialization of the object during its creation. </P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>LO</TD><TD ALIGN=left NOWRAP>Topic</TD><TD ALIGN=left NOWRAP>Java Files (.java)</TD><TD ALIGN=center NOWRAP>Prerequisites</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.01">4.1</A></TD><TD ALIGN=left NOWRAP>What are constructors for?</TD><TD ALIGN=left NOWRAP>Constructor01A, B, C</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.02">4.2</A></TD><TD ALIGN=left NOWRAP>Computation within constructors</TD><TD ALIGN=left NOWRAP>Constructor02</TD><TD ALIGN=center NOWRAP>1</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.03">4.3</A></TD><TD ALIGN=left NOWRAP>Overloading constructors</TD><TD ALIGN=left NOWRAP>Constructor03</TD><TD ALIGN=center NOWRAP>2</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.04">4.4</A></TD><TD ALIGN=left NOWRAP>Invoking another constructor</TD><TD ALIGN=left NOWRAP>Constructor04</TD><TD ALIGN=center NOWRAP>3</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.05">4.5</A></TD><TD ALIGN=left NOWRAP>Explicit default constructors</TD><TD ALIGN=left NOWRAP>Constructor05</TD><TD ALIGN=center NOWRAP>3</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.06">4.6</A></TD><TD ALIGN=left NOWRAP>Constructors for subclasses</TD><TD ALIGN=left NOWRAP>Constructor06A, B, C</TD><TD ALIGN=center NOWRAP>3</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.07">4.7</A></TD><TD ALIGN=left NOWRAP>Constructors with object parameters</TD><TD ALIGN=left NOWRAP>Constructor07</TD><TD ALIGN=center NOWRAP>3</TD></TR>
<TR><TD ALIGN=center NOWRAP><A HREF="#con.08">4.8</A></TD><TD ALIGN=left NOWRAP>Constructors with subclass</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>object parameters</TD><TD ALIGN=left NOWRAP>Constructor08</TD><TD ALIGN=center NOWRAP>6, 7</TD></TR>
</TABLE>
</DIV><P><B>Program</B> The example used in these LOs is class <TT>Song</TT> with three fields: the <TT>name</TT> of the song, the length of the song in <TT>seconds</TT> and the <TT>pricePerSecond</TT>. The class is to be used to implement a website which charges for downloading the song; the price is the product of the length of the song in second and the price per second. To focus the discussion on constructors, the fields are not declared private.</P><H3 CLASS="subsection"><A NAME="htoc32">4.1</A>&#XA0;&#XA0;What are constructors for?</H3><P><A NAME="con.01"></A></P><P><B>Concept</B> An object is created by allocating memory for its fields. The fields are given the default values for their types. A reference to the object is returned and assigned to a variable; the reference can be used to access the fields and methods of the object.</P><P><B>Program: Constructor01A.java</B>
, <A HREF="src/constructor/Constructor01A.java">click to display source</A>.<BR>

If a constructor is not explicitly declared a default constructor is called.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the fields of the object; this is displayed in the Instance and Array Area. Default values are assigned to the three fields.
</LI><LI CLASS="li-itemize">The default constructor is called 
but does nothing except return a reference to the object.
</LI><LI CLASS="li-itemize">The reference is stored in the variable <TT>song1</TT>.
</LI><LI CLASS="li-itemize">The reference in <TT>song1</TT> is used to assign values to the fields of the object.
</LI><LI CLASS="li-itemize">The reference in <TT>song1</TT> is used to call the method <TT>computePrice</TT> on the object; the method computes and returns the price, 
which is assigned to the variable <TT>price</TT>.
</LI></UL><P><BR>
<BR>
</P><P><B>Concept</B> An explicit constructor method can be declared and used 
to initialize each object. 
The constructor method is identified by a special syntax: the name of the method is the same as the name of the class and <EM>there is no return type</EM> (because the value returned is of the type of the class itself).</P><P><B>Program: Constructor01B.java</B>
, <A HREF="src/constructor/Constructor01B.java">click to display source</A>.<BR>

This program is the same as the previous one except that the assignment of nondefault values to the fields of the object is moved to an explicit constructor.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the fields of the object; this is displayed in the Instance and Array Area. Default values are assigned to the three fields.
</LI><LI CLASS="li-itemize">The constructor is called and assigns values to the three fields; 
then it returns a reference to the object.
</LI><LI CLASS="li-itemize">The reference is stored in the variable <TT>song1</TT>.
</LI><LI CLASS="li-itemize">The reference in <TT>song1</TT> is used to call the method <TT>computePrice</TT> on the object; the method computes and returns the price,
which is assigned to the variable <TT>price</TT>.
</LI></UL><P><B>Exercise</B> Add the creation of a second object <TT>song2</TT> to the
program and verify that it is initialized to the same values.</P><P><BR>
<BR>
</P><P><B>Concept</B> Of course, it is highly unlikely that all objects created from a class will be initialized with the same values. A constructor can have formal parameters like any other method and is called with actual parameters.</P><P><B>Program: Constructor01C.java</B>, <A HREF="src/constructor/Constructor01C.java">click to display source</A>.<BR>

This program is the same as the previous one except that the constructor has formal parameters and the actual parameters passed to the constructor are assigned to the fields of the object.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the fields of the object; this is displayed in the Instance and Array Area. Default values are assigned to the three fields.
</LI><LI CLASS="li-itemize">The constructor is called with three actual parameters; these values are assigned to the formal parameters of the constructor method.
</LI><LI CLASS="li-itemize">The values of the formal parameters are assigned to the three fields; then the constructor returns a reference to the object.
</LI><LI CLASS="li-itemize">The reference is stored in the variable <TT>song1</TT>.
</LI><LI CLASS="li-itemize">The reference in <TT>song1</TT> is used to call the method <TT>computePrice</TT> on the object; the method computes and returns the price,
which is assigned to the variable <TT>price</TT>.
</LI></UL><P><B>Exercise</B> Modify the class so that the second parameter passes
the number of minutes; the value of the field <TT>seconds</TT> will have
to be computed in the constructor.

</P><H3 CLASS="subsection"><A NAME="htoc33">4.2</A>&#XA0;&#XA0;Computation within constructors</H3><P><A NAME="con.02"></A></P><P><B>Concept</B> Constructors are often used simply for assigning initial values to fields of an object; however, an arbitrary initializing computation can be carried out within the constructor.</P><P><B>Program: Constructor02.java</B>, <A HREF="src/constructor/Constructor02.java">click to display source</A>.<BR>

The price of a song will not change as long as the fields <TT>second</TT> and
<TT>pricePerSecond</TT> do not change; to avoid recomputing the price each time it is needed,
the class contains a field <TT>price</TT> whose value is computed <EM>within</EM> the
constructor. The method <TT>computePrice</TT> is declared to be <TT>private</TT> 
because it is needed only by the constructor.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the fields of the object and default values are assigned to the three fields.
</LI><LI CLASS="li-itemize">The constructor is called with three actual parameters; these values are assigned to the formal parameters of the constructor method and the values of the formal parameters are assigned to the three fields.
</LI><LI CLASS="li-itemize">The method <TT>computePrice</TT> is called; it returns a value which stored in the field <TT>price</TT>.
</LI><LI CLASS="li-itemize">The constructor returns a reference to the object, which is stored in the variable <TT>song1</TT>. The field <TT>price</TT> can be accessed to obtain the price of a song.
</LI></UL><P><B>Exercise</B> Modify the class so that no song has a price greater than two 
currency units.

</P><H3 CLASS="subsection"><A NAME="htoc34">4.3</A>&#XA0;&#XA0;Overloading constructors</H3><P><A NAME="con.03"></A></P><P><B>Concept</B> Constructors can be <EM>overloaded</EM> like other methods. A method is overloaded when there is more than one method with the same name; the parameter signature is used to decide which method to call. For constructors, overloading is usually done when some of the fields of an object can be initialized with default values, although we want to retain 
the possibility of explicitly supplying all the initial values.</P><P><B>Program: Constructor03.java</B>, <A HREF="src/constructor/Constructor03.java">click to display source</A>.<BR>

The website charges a uniform price per second for all songs, except for special offers. We define two constructors, one that specifies a price for special offers and another that uses a default price for ordinary songs.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The value of the static constant <TT>DEFAULT_PRICE</TT> is set as soon as the class is loaded and is displayed in the Constant area.
</LI><LI CLASS="li-itemize">The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the <EM>four</EM> fields of the object and default values are assigned to the fields. 
</LI><LI CLASS="li-itemize">The constructor is called with <EM>three</EM> actual parameters; the call is resolved so that the first constructor is executed. These values are assigned to the formal parameters of the constructor method and the values of the formal parameters are assigned to the three fields. 
</LI><LI CLASS="li-itemize">The method <TT>computePrice</TT> is called; it returns a value which stored in the field <TT>price</TT>.
</LI><LI CLASS="li-itemize">The constructor returns a reference to the object, which is stored in the variable <TT>song1</TT>.
</LI><LI CLASS="li-itemize">The computation is then repeated for <TT>song2</TT>.
Since the constructor is called with just two parameters (for <TT>name</TT> and <TT>seconds</TT>),
the second constructor is executed. 
The value of the field <TT>pricePerSecond</TT> is assigned from the constant, not from a parameter.
</LI></UL><P><B>Exercise</B> Modify the class to include a constructor with one parameter for the <TT>name</TT> and with a default song length of three minutes.</P><P><B>Exercise</B> Modify the class to include a constructor with no parameters, so that all fields receive default values. Is there any meaning to the following constructor?</P><P>&#XA0;&#XA0;&#XA0;<TT>Song() {</TT><BR>
&#XA0;&#XA0;&#XA0;<TT>}</TT>

</P><H3 CLASS="subsection"><A NAME="htoc35">4.4</A>&#XA0;&#XA0;Invoking an overloaded constructor from within a constructor</H3><P><A NAME="con.04"></A></P><P><B>Concept</B> Constructors can be <EM>overloaded</EM> like other methods. A method is overloaded when there is more than one method with the same name; the parameter signature is used to decide which method to call. For constructors, overloading is usually done when some of the fields of an object can be initialized with default values, although we want to retain 
the possibility of explicitly supplying all the initial values. In such cases, it is convenient to invoke one constructor from within another in order to avoid duplicating code. Invoking the method <TT>this</TT> within one constructor calls another constructor
with the appropriate parameter signature.</P><P><B>Program: Constructor04.java</B>, <A HREF="src/constructor/Constructor04.java">click to display source</A>.<BR>

The website charges a uniform price per second for all songs, except for special offers. We define two constructors, one that specifies a price for special offers and another that uses a default price for ordinary songs.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The value of the static constant <TT>DEFAULT_PRICE</TT> is set as soon as the class is loaded and is displayed in the Constant area.
</LI><LI CLASS="li-itemize">The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the <EM>four</EM> fields of the object and default values are assigned to the fields. 
</LI><LI CLASS="li-itemize">The constructor is called with <EM>two</EM> actual parameters; the call is resolved so that it is the second constructor that is executed. 
</LI><LI CLASS="li-itemize">The two parameters, together with the default price, are immediately used to call the 
first constructor that has three parameters. The method name <TT>this</TT> means: call a
constructor from <EM>this</EM> class. This constructor initializes the first three fields from the parameters, and the value of the fourth field is computed by calling the method <TT>computePrice</TT>.
</LI><LI CLASS="li-itemize">The constructor returns a reference to the object, which is stored in the variable <TT>song1</TT>.
</LI></UL><P><B>Exercise</B> Modify the class to include a constructor with one parameter, the name, and with a default song length of three minutes. Can this constructor call the two-parameter constructor which in turn calls the three-parameter constructor? Can a constructor call <EM>two</EM> other constructors, one after another?

</P><H3 CLASS="subsection"><A NAME="htoc36">4.5</A>&#XA0;&#XA0;Explicit default constructors</H3><P><A NAME="con.05"></A></P><P><B>Concept</B> When no constructor is explicitly written in a class, a default implicit constructor with no parameters exists; this constructor does nothing. If, however, one or more explicit constructors are given, there is no longer a constructor with no parameters.
Should you want one, you have to write it explicitly.</P><P><B>Program: Constructor05.java</B>
, <A HREF="src/constructor/Constructor05.java">click to display source</A>.<BR>

This program includes an explicit constructor with no parameters that calls the constructor with three parameters to perform initialization.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the <EM>four</EM> fields of the object and default values are assigned to the fields. 
</LI><LI CLASS="li-itemize">The constructor is called with <EM>no</EM> actual parameters; the call is resolved so that it is the second constructor that is executed. 
</LI><LI CLASS="li-itemize">Three constant values are used to call the first constructor. The method name <TT>this</TT> means: call a constructor from <EM>this</EM> class. 
This constructor initializes the first three fields from the parameters, and the value of the fourth field is computed by calling the method <TT>computePrice</TT>.
</LI><LI CLASS="li-itemize">The constructor returns a reference to the object, which is stored in the variable <TT>song1</TT>.
</LI></UL><P><B>Exercise</B> Modify the class so that the constructor without parameters 
obtains initial values from the input.

</P><H3 CLASS="subsection"><A NAME="htoc37">4.6</A>&#XA0;&#XA0;Constructors for subclasses</H3><P><A NAME="con.06"></A></P><P><B>Concept</B> Constructors are <EM>not</EM> inherited. You must 
explicitly define a constructor for a subclass (with or without 
parameters). As its first statement, the constructor for the subclass must 
call a constructor for the superclass using the method <TT>super</TT>.</P><P><B>Program: Constructor06A.java</B>
, <A HREF="src/constructor/Constructor06A.java">click to display source</A>.<BR>

The website wants to sell certain songs at a discount.
The subclass <TT>DiscountSong</TT> inherits from class 
<TT>Song</TT>, adds a field <TT>discount</TT> and overrides 
<TT>computePrice</TT> to include <TT>discount</TT> in the computation. 
The constructor for the subclass calls the three-parameter constructor for 
the superclass, passing it the three parameters that it expects. The 
fourth parameter is used directly in the constructor <TT>DiscountSong</TT> 
to initialize the field <TT>discount</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The variable <TT>song1</TT> is allocated and contains the null value.
</LI><LI CLASS="li-itemize">Memory is allocated for the <EM>five</EM> fields of the object of the subclass <TT>DiscountSong</TT> and default values are assigned to the fields. 
Four fields inherited from the superclass and one field <TT>discount</TT> 
added by the subclass.
</LI><LI CLASS="li-itemize">The constructor for the subclass <TT>DiscountSong</TT> is called 
with four parameters. It calls the constructor for the superclass 
<TT>Song</TT> which assigns values to three fields from the parameters and 
the fourth by calling <TT>computePrice</TT>.
</LI><LI CLASS="li-itemize">The superclass constructor returns and then the fourth parameter of 
the subclass constructor is assigned to the field <TT>discount</TT>.
</LI><LI CLASS="li-itemize">The reference to the subclass object is returned and assigned to a 
variable <TT>song1</TT> of that type.
</LI></UL><P>
Unfortunately, this does not do what we intended, because the superclass 
method for <TT>computePrice</TT> is used to compute <TT>price</TT> 
instead of the method from the subclass.</P><P><B>Exercise</B> Could <TT>song1</TT> be declared to be of type
<TT>Song</TT>? Explain your answer.</P><P><BR>
<BR>
</P><P><B>Program: Constructor06B.java</B>
, <A HREF="src/constructor/Constructor06B.java">click to display source</A>.<BR>

The problem can be solved by adding a call to 
<TT>computePrice</TT> in the constructor for the subclass. </P><P>Check this by executing the code and ensuring that the discounted price is computed.</P><P>The disadvantage of this solution is that we are calling 
<TT>computePrice</TT> twice.</P><P><BR>
<BR>
</P><P><B>Program: Constructor06C.java</B>
, <A HREF="src/constructor/Constructor06C.java">click to display source</A>.<BR>

Normally in an object-oriented program, all the 
fields of an object are private and an accessor method like 
<TT>getPrice()</TT> is used to access the values of the fields.
If this is done, the computation of the price can be placed in 
the accessor for the superclass and overridden in accessor for the 
subclass. </P><P>Check this by executing the code and ensuring that the discounted price is computed.</P><P>The disadvantage of this solution is that the computation is 
performed for each access of the field <TT>price</TT>.</P><P><B>Exercise</B> Develop other solutions for this problem: (a) Call
<TT>computePrice</TT> explicitly after the call to the constructor; (b)
Modify <TT>getPrice</TT> to compute the value of <TT>price</TT> on the first
call and save it for future calls. Summarize the advantages and
disadvantages of all the solutions for this problem.

</P><H3 CLASS="subsection"><A NAME="htoc38">4.7</A>&#XA0;&#XA0;Constructors with object parameters</H3><P><A NAME="con.07"></A></P><P><B>Concept</B> An object can contain fields of other user-defined 
objects, not just of primitive and predefined types. There is no 
difference in the constructors, except that references to objects are
passed as actual parameters and assigned to fields of the object.</P><P><B>Program: Constructor07.java</B>
, <A HREF="src/constructor/Constructor07.java">click to display source</A>.<BR>

Two objects of type <TT>Song</TT> are allocated and 
assigned to fields of another object of type 
<TT>SongSet</TT> which has two fields of type <TT>Song</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Execute the program until the two objects of type <TT>Song</TT> are 
allocated and their references assigned to the variables <TT>song1</TT> and <TT>song2</TT>.
(You may want to select <TT>Animation / Run Until (ctrl-T)</TT> to skip the 
animation of these declarations.)
</LI><LI CLASS="li-itemize">A variable <TT>set</TT> is allocated. An object of type 
<TT>SongSet</TT> is allocated with default null fields.
</LI><LI CLASS="li-itemize">The constructor for <TT>SongSet</TT> is called and the references in the two variables
<TT>song1</TT> and <TT>song2</TT> are passed as actual parameters. These references 
are stored in the two fields <TT>track1</TT> and <TT>track2</TT>.
</LI><LI CLASS="li-itemize">The reference to the object of class <TT>SongSet</TT> 
is returned and stored in <TT>set</TT>. 
</LI><LI CLASS="li-itemize">The prices of the two objects are obtained and stored in the variables
<TT>price1</TT> and <TT>price2</TT>. <TT>set</TT> is an object 
of type <TT>Songset</TT>, while <TT>set.track1</TT> is an object of type 
<TT>Song</TT> and thus can be used to call the method 
<TT>computePrice</TT>.
</LI></UL><P><B>Exercise</B> Modify the program so that the variables <TT>song1</TT> and
<TT>song2</TT> are not used; instead, the constructors for the songs are
embedded within the constructor call for <TT>SongSet</TT>.</P><P><B>Exercise</B> Modify the program so the constructors for the songs are
call within the constructor for <TT>SongSet</TT>. Under what circumstances
would this be done?

</P><H3 CLASS="subsection"><A NAME="htoc39">4.8</A>&#XA0;&#XA0;Constructors with subclass object parameters</H3><P><A NAME="con.08"></A></P><P><B>Concept</B> An object of a subclass is also an object of the type of the 
superclass. Therefore, it can be used when an actual parameter is expected.</P><P><B>Program: Constructor08.java</B>
, <A HREF="src/constructor/Constructor08.java">click to display source</A>.<BR>

We allocate two objects, one of type <TT>Song</TT> and 
one of type <TT>DiscountSong</TT>, and use them as actual parameters in 
the constructor for an object of type <TT>SongSet</TT> that expects two 
parameters of type <TT>Song</TT>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Execute the program until the two objects one of type <TT>Song</TT> 
the other of type <TT>DiscountSong</TT> are 
allocated and their references assigned to the variables <TT>song1</TT> and <TT>song2</TT>,
respectively.
(You may want to select <TT>Animation / Run Until (ctrl-T)</TT> to skip the 
animation of these declarations.)
</LI><LI CLASS="li-itemize">The variable <TT>set</TT> is allocated, and an object of type 
<TT>SongSet</TT> is allocated with default null fields.
</LI><LI CLASS="li-itemize">The constructor for <TT>SongSet</TT> is called and the references in the two variables
<TT>song1</TT> and <TT>song2</TT> are passed as actual parameters. These references 
are stored in the two fields <TT>track1</TT> and <TT>track2</TT>.
</LI><LI CLASS="li-itemize">The reference to the object of class <TT>SongSet</TT> 
is returned and stored in <TT>set</TT>. 
</LI><LI CLASS="li-itemize">The prices of the two objects are obtained and stored in the variables
<TT>price1</TT> and <TT>price2</TT>. <TT>set</TT> is an object 
of type <TT>Songset</TT>, while <TT>set.track1</TT> is an object of type 
<TT>Song</TT> and thus can be used to call the method 
<TT>computePrice</TT> of that class. Similarly for <TT>price2</TT>,
except that <TT>set.track2</TT> is an object of type 
<TT>DiscountSong</TT>; check that the method <TT>computePrice</TT> of this
class is called.
</LI></UL><P><B>Exercise</B> Can <TT>s2</TT> in the main method be declared to be of type
<TT>Song</TT>? Explain.</P><HR>
<A HREF="lov006.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="lov008.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
